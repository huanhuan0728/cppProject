# leetcode27（双指针、原地删除）

```
    给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素。元素的顺序可能发生改变。然后返回 nums 中与 val 不同的元素的数量。
    假设 nums 中不等于 val 的元素数量为 k，要通过此题，您需要执行以下操作：
    更改 nums 数组，使 nums 的前 k 个元素包含不等于 val 的元素。nums 的其余元素和 nums 的大小并不重要。
    返回 k。
```

双指针法，左指针找到第一个值为 val 的元素，右指针找到第一个值不为 val 的元素，交换二者

## while(A && B) while(B && A)

有区别，第一个条件为假的时候第二个条件不再检查
在 leetcode27：
版本 1（安全）：先检查边界再检查元素

```python
    // 正确顺序：先检查 left <= right，再访问元素
    while (left <= right && nums[right] == val)
```

版本 2（危险）：先访问元素，再检查边界

```python
    // 错误顺序：先访问元素，再检查 left <= right
    while (nums[left] != val && left <= right)
```

# NULL 和 nullptr

NULL 是“老派”的，有点像用数字 0 来假装自己是个空指针，有时会造成误解。
nullptr 是“现代”的，它本身就是一种特殊的“空指针类型”，更安全、更明确。

本质: NULL 是一个宏。
定义: 在 C++中，NULL 通常被定义为整数 0 或者 0L (long int)。在某些 C 头文件中（也可能被 C++包含），它可能被定义为 ((void*)0)。
#define NULL 0 (常见于 C++实现)
#define NULL 0L
#define NULL ((void*)0) (常见于 C，有时也用于 C++)
类型:
如果 NULL 被定义为 0，那么它的类型是 int。
如果 NULL 被定义为 ((void*)0)，那么它的类型是 void*。
问题 (主要当 NULL 被定义为 0 时):
函数重载歧义: 这是最大的问题。如果一个函数有针对整数类型和指针类型的重载，传递 NULL (如果它是 0) 可能会导致编译器无法确定调用哪个版本的函数，或者更糟的是，调用了非预期的整数版本。

本质: nullptr 是一个关键字，它代表一个空指针常量。
类型: nullptr 有一个特殊的类型，叫做 std::nullptr_t。这个类型定义在 <cstddef> 头文件中。
优点:
类型安全: std::nullptr_t 是一种独特的类型，它只能被隐式转换到任何指针类型或 bool 类型（在布尔上下文中为 false）。它不能被隐式转换为整数类型。
解决函数重载歧义: 由于 nullptr 有自己明确的指针类型，它不会与整数类型的重载发生混淆。
